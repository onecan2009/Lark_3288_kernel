From aca6831ebe4c8be3aaccfe94e6b922a0fd3ce46c Mon Sep 17 00:00:00 2001
From: cjp <service@t-firefly.com>
Date: Fri, 24 Nov 2017 18:00:40 +0800
Subject: [PATCH 15/16] [kernel] video: lcdc: rk3288w update bcsh

---
 kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c |   33 +++++++++++++++++++++-
 kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h |    8 ++++++
 kernel/drivers/video/rockchip/rkfb_sysfs.c       |    2 +-
 kernel/include/linux/rk_fb.h                     |   10 +++++++
 4 files changed, 51 insertions(+), 2 deletions(-)
 mode change 100755 => 100644 kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c
 mode change 100755 => 100644 kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h
 mode change 100755 => 100644 kernel/drivers/video/rockchip/rkfb_sysfs.c
 mode change 100755 => 100644 kernel/include/linux/rk_fb.h

diff --git a/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c b/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c
old mode 100755
new mode 100644
index a26d558..bb6a873
--- a/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c
+++ b/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.c
@@ -280,6 +280,9 @@ static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
 	for (reg = 0; reg < 0x1a0; reg+= 4) {
 		val = lcdc_readl(lcdc_dev, reg);
 		switch (reg) {
+			case VERSION_INFO:
+				lcdc_dev->driver.version = val;
+			break;
 			case WIN0_ACT_INFO:
 				win0->area[0].xact = (val & m_WIN0_ACT_WIDTH)+1;
 				win0->area[0].yact = ((val & m_WIN0_ACT_HEIGHT)>>16)+1;
@@ -1058,10 +1061,30 @@ static int rk3288_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv)
 
 }
 
+static void rk3288_lcdc_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 bcsh_color_bar;
+
+	bcsh_color_bar = lcdc_readl(lcdc_dev, BCSH_COLOR_BAR);
+	if (((bcsh_color_bar & m_BCSH_EN) == 1) ||
+	    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
+		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+			     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+			     v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(1));
+	else
+		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+			     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+			     v_BCSH_R2Y_EN(0) | v_BCSH_Y2R_EN(0));
+}
+
 static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
 {
 	u16 face = 0;
 	u32 v=0;
+	int ret = 0;
+
 	struct lcdc_device *lcdc_dev =
 	    container_of(dev_drv, struct lcdc_device, driver);
 	struct rk_screen *screen = dev_drv->cur_screen;
@@ -1208,6 +1231,10 @@ static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
 		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
 
 		rk3288_lcdc_post_cfg(dev_drv);
+		//dev_drv->output_color = screen->color_mode;
+		if (dev_drv->version == VOP_FULL_RK3288_V1_1) {
+			rk3288_lcdc_bcsh_path_sel(dev_drv);
+		} 
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 	rk3288_lcdc_set_dclk(dev_drv);
@@ -1216,7 +1243,7 @@ static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
 	if (screen->init)
 		screen->init();
 	
-	return 0;
+	return ret;
 }
 
 /*enable layer,open:1,enable;0 disable*/
@@ -3586,12 +3613,16 @@ static int rk3288_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
 			lcdc_writel(lcdc_dev,BCSH_COLOR_BAR,0x1);
 			lcdc_writel(lcdc_dev,BCSH_BCS,0xd0010000);
 			lcdc_writel(lcdc_dev,BCSH_H,0x01000000);
+			dev_drv->bcsh.enable = 1;
 		} else {
 			mask = m_BCSH_EN;
 			val = v_BCSH_EN(0);
 			lcdc_msk_reg(lcdc_dev, BCSH_COLOR_BAR, mask, val);
+			dev_drv->bcsh.enable = 0;
 		}
 		lcdc_cfg_done(lcdc_dev);
+		if (dev_drv->version == VOP_FULL_RK3288_V1_1)
+			rk3288_lcdc_bcsh_path_sel(dev_drv);
 	}
 	spin_unlock(&lcdc_dev->reg_lock);
 	return 0;
diff --git a/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h b/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h
old mode 100755
new mode 100644
index c18eeb1..54e1a75
--- a/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h
+++ b/kernel/drivers/video/rockchip/lcdc/rk3288_lcdc.h
@@ -13,6 +13,8 @@
 #define m_RTL_VERSION 			(0xffff<<0)
 #define m_FPGA_VERSION			(0xffff<<16)
 #define SYS_CTRL                	(0x0008)
+#define VOP_FULL_RK3288_V1_0		0x03007236
+#define VOP_FULL_RK3288_V1_1		0x0a050a01
 #define v_DIRECT_PATH_EN(x)     	(((x)&1)<<0)
 #define v_DIRECT_PATCH_SEL(x)   	(((x)&3)<<1)
 #define v_DOUB_CHANNEL_EN(x)    	(((x)&1)<<3)
@@ -1062,6 +1064,12 @@
 #define m_BCSH_SIN_HUE			(0x1ff<<0)
 #define m_BCSH_COS_HUE			(0x1ff<<16)
 
+#define BCSH_CTRL                       (0x01bc)
+#define v_BCSH_Y2R_EN(x)                (((x)&0x1)<<0)
+#define v_BCSH_R2Y_EN(x)                (((x)&0x1)<<4)
+#define m_BCSH_Y2R_EN                   (0x1<<0)
+#define m_BCSH_R2Y_EN                   (0x1<<4)
+
 #define CABC_CTRL0 			(0x01c0)
 #define v_CABC_EN(x)			(((x)&1)<<0)
 #define v_CABC_CALC_PIXEL_NUM(x)	(((x)&0x7fffff)<<1)
diff --git a/kernel/drivers/video/rockchip/rkfb_sysfs.c b/kernel/drivers/video/rockchip/rkfb_sysfs.c
old mode 100755
new mode 100644
index 5cd4c3c..434d069
--- a/kernel/drivers/video/rockchip/rkfb_sysfs.c
+++ b/kernel/drivers/video/rockchip/rkfb_sysfs.c
@@ -332,7 +332,7 @@ static ssize_t show_dsp_bcsh(struct device *dev,
 	sin_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv,H_SIN);
 	cos_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv,H_COS);
 
-	snprintf(buf, PAGE_SIZE, "brightness:%4d,contrast:%4d,sat_con:%4d,"
+	return snprintf(buf, PAGE_SIZE, "brightness:%4d,contrast:%4d,sat_con:%4d,"
 				 "sin_hue:%4d,cos_hue:%4d\n",
 				 brightness, contrast,sat_con,sin_hue,cos_hue);
 	return 0;
diff --git a/kernel/include/linux/rk_fb.h b/kernel/include/linux/rk_fb.h
old mode 100755
new mode 100644
index c591d50..9e66057
--- a/kernel/include/linux/rk_fb.h
+++ b/kernel/include/linux/rk_fb.h
@@ -523,12 +523,21 @@ struct rk_fb_reg_data {
 	//int     fence_wait_begin;
 };
 
+struct rk_lcdc_bcsh {
+	bool enable;
+	u16 brightness;
+	u16 contrast;
+	u16 sat_con;
+	u16 sin_hue;
+	u16 cos_hue;
+};
 
 struct rk_lcdc_driver {
 	char name[6];
 	int id;
 	int prop;
 	struct device *dev;
+	u32 version;
 
 	struct rk_lcdc_win *win[RK_MAX_FB_SUPPORT];
 	int lcdc_win_num;
@@ -580,6 +589,7 @@ struct rk_lcdc_driver {
 	void (*irq_call_back)(struct rk_lcdc_driver *driver);
 #endif
 	struct overscan overscan;
+	struct rk_lcdc_bcsh bcsh;
 	int enable;
 	int config_done;
 	struct device *mmu_dev;
-- 
1.7.9.5

